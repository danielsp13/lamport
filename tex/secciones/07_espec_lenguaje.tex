\chapter{\textbf{Estudio y diseño del lenguaje Lamport}}
El lenguaje \textit{Lamport}, nombrado en honor al renombrado informático Leslie Lamport, emerge como una herramienta didáctica y a la vez completamente funcional. Su propósito es modelar, diseñar y simular sistemas concurrentes y distribuidos.



En este capítulo, se llevará a cabo un estudio detallado sobre el pseudocódigo propuesto en la asignatura \textit{Sistemas Concurrentes y Distribuidos}, que sustentará la base del lenguaje destino \textit{Lamport}. Se discutirán sus objetivos de diseño, principales características y cómo estas contribuyen a abordar los desafíos de modelar y simular sistemas concurrentes. Se profundizará en aspectos como la sintaxis, semántica y otras características esenciales. Finalmente, se presentará una definición formal de la gramática del lenguaje Lamport, orientada a ser un recurso valioso para quienes aspiren a aprender o instruir sobre sistemas concurrentes, e incluso utilizarlo como un lenguaje de programación más.

\section{Análisis del pseudocódigo base}\label{sec:pseudoAnalisis}
El pseudocódigo, una representación abstracta y simplificada de la lógica de programación, es un elemento crucial en la fase de diseño de sistemas informáticos. En la asignatura \textit{Sistemas Concurrentes y Distribuidos}, se propone un pseudocódigo específico que sienta las bases para la concepción del lenguaje \textit{Lamport}. Analizar este pseudocódigo nos permite entender su estructura, características y potenciales áreas de mejora o adaptación.



A continuación se presentarán una serie de ejemplos representativos del pseudocódigo, ilustrando sus principales componentes. Posteriormente, se desglosarán sus elementos fundamentales y se considerará su relación con lenguajes de programación más convencionales, permitiendo así contextualizar su diseño y utilidad.

\newpage

\subsection{Ejemplos de pseudocódigo}\label{subsec:pseudoAnalisisEjemplos}

Los ejemplos que se presentan a continuación ofrecen una vista panorámica sobre la utilización del pseudocódigo en diferentes contextos. Cada uno ilustra un escenario particular en la modelación y simulación de sistemas concurrentes y distribuidos, haciendo uso de las estructuras, declaraciones y procesos propios del pseudocódigo. Estos ejemplos servirán como base para el análisis detallado de los componentes sintácticos y semánticos que se llevará a cabo en las subsecciones posteriores.

\subsubsection{Ejemplo 1: Paradigma del Productor-Consumidor}\label{subsubsec:pseudoAnalisisEjemplo1}
Este ejemplo muestra la interacción entre dos procesos cooperantes en los cuales uno de ellos \textit{productor} genera una secuencia de valores (como por ejemplo, enteros) y el otro \textit{consumidor} utiliza cada uno de estos valores.

\begin{figure}[h]
\begin{lstlisting}[style=lamportStyle]
var x : integer; {contiene cada valor producido}

{Proceso productor: calcula 'x'}
process Productor;
var a : integer; {no compartida}
begin
  while true do begin
    {calcular un valor}
    a := ProducirValor();
    {escribir en mem. compartida}
    x := a; {sentencia E}
  end
end

{Proceso consumidor: lee 'x'}
process Consumidor;
var b : integer;
begin
  while true do begin
    {leer de mem. compartida}
    b := x; {sentencia L}
    {utilizar el valor leido}
    UsarValor(b);
  end
end
\end{lstlisting}
\caption{Ejemplo del problema del productor-consumidor en pseudocódigo.}
\label{fig:ejemplo1}
\end{figure}

\newpage


A partir de este ejemplo, es posible identificar componentes y patrones que serán importantes para el diseño del código \textit{Lamport}. A continuación, se enumeran y detallan algunas de las características más relevantes:

\begin{itemize}
    \item \textbf{Variables}: Estos elementos, presentes en las líneas 1, 5 y 17 y con nombres \code{x}, \code{a} y \code{b} respectivamente, son fundamentales en la mayoría de los lenguajes de programación. Las variables permiten almacenar y manipular datos de diferentes tipos.
    
    \item \textbf{Ámbitos de las Variables (Scopes)}: En este pseudocódigo, es posible distinguir entre variables globales y locales. La variable \code{x} es global y, por lo tanto, es accesible desde cualquier proceso del programa. Por otro lado, las variables \code{a} y \code{b} son locales a sus respectivos procesos, lo que significa que solo son conocidas y manipulables dentro del proceso en el que se declaran.

    \item \textbf{Tipos de dato de Variables}: Se refiere a la categoría de dato que una variable puede almacenar. En el pseudocódigo, vemos que se hace uso del tipo de dato \code{integer} para representar números enteros. Esto se aprecia en las declaraciones de las variables en las líneas 1, 5 y 17. Definir el tipo de dato es crucial, ya que delimita las operaciones que se pueden realizar con la variable y la cantidad de memoria que se reserva para ella. Así, cuando se asigna un valor a una variable, el sistema sabe cómo interpretar y manipular ese dato en función de su tipo.

    \item \textbf{Procesos}: Son unidades fundamentales de ejecución en este pseudocódigo. Cada proceso encapsula un conjunto de instrucciones que se ejecutan de manera secuencial o concurrente. En el ejemplo anterior, se identifican dos procesos: el \code{Productor} (definido a partir de la línea 4) y el \code{Consumidor} (definido a partir de la línea 16). Estos procesos tienen sus propias variables locales y pueden interactuar con variables globales. La palabra clave \code{process} indica el comienzo de la definición de un proceso, y todo lo que sigue, hasta el \code{end} correspondiente, pertenece a ese proceso. Estos procesos pueden ejecutarse de manera concurrente o en paralelo, dependiendo del contexto del programa.

    \item \textbf{Bucles While}: El bucle \code{while} es una estructura de control que permite repetir un conjunto de instrucciones mientras una condición sea verdadera. En el pseudocódigo presentado, observamos bucles \code{while} en los procesos \code{Productor} y \code{Consumidor} (a partir de las líneas 7 y 19, respectivamente). Aquí, el conjunto de instrucciones dentro del bucle se ejecuta indefinidamente debido a la condición \code{true}. Este tipo de bucles es importante para modelar operaciones que deben continuar hasta que se cumpla una condición específica o, como en este caso, para operaciones que deben continuar en un ciclo perpetuo.

    \item \textbf{Llamadas a funciones y procedimientos}: Estas estructuras son vitales para organizar el código, permitiendo la reutilización y modularidad. Una llamada a función o procedimiento invoca un conjunto específico de instrucciones predefinidas. En el pseudocódigo presentado, encontramos ejemplos de llamadas a funciones con \code{ProducirValor()} (línea 9) y \code{UsarValor(b)} (línea 23). La diferencia principal entre funciones y procedimientos es que las funciones generalmente devuelven un valor, mientras que los procedimientos realizan una acción sin necesariamente devolver algo. Estas llamadas sirven para simplificar el código y evitar redundancias, permitiendo una estructuración más clara y organizada del programa.

    \item \textbf{Operaciones de Asignación}: Una de las operaciones fundamentales en cualquier lenguaje de programación es la capacidad de asignar valores a variables. Las asignaciones permiten que los programas capturen y modifiquen estados dinámicamente durante su ejecución. En el pseudocódigo presentado, observamos asignaciones en como \code{a := ProducirValor();} (línea 9) y \code{x := a;} (línea 21). El operador \code{:=} es utilizado para denotar la acción de asignar el valor del lado derecho al identificador del lado izquierdo. La correcta gestión de asignaciones es esencial para garantizar que el programa funcione de manera adecuada y predecible, especialmente en contextos concurrentes donde las operaciones de lectura y escritura deben ser cuidadosamente coordinadas.

    \item \textbf{Comentarios}: Los comentarios son fragmentos de texto que se incluyen en el código con el propósito de proporcionar explicaciones adicionales o aclaraciones sobre la lógica o el propósito del código, pero que no se ejecutan como parte del programa. En el pseudocódigo presentado, los comentarios están demarcados por llaves \code{\{\}}. Por ejemplo, en la línea 1, \code{\{contiene cada valor producido\}} es un comentario que ofrece información sobre la variable \code{x}. Los comentarios son útiles para garantizar la legibilidad y comprensión del código, especialmente cuando se comparte con otros desarrolladores o para referencia futura.
\end{itemize}

\subsubsection{Ejemplo 2: Ordenación de Arrays utilizando procedimientos}\label{subsubsec:pseudoAnalisisEjemplo2}
El siguiente ejemplo ilustra cómo se pueden ordenar y copiar arrays utilizando procedimientos en el pseudocódigo. A través de funciones como \code{Sort} y \code{Copiar}, se demuestra cómo la modularidad y la reutilización de código son posibles, lo que mejora la legibilidad y la estructura del programa.

\newpage

\begin{figure}[h]
\begin{lstlisting}[style=lamportStyle]
var a,b : array[1..2*n] integer; {n es una constante predefinida}

procedure Sort( s,t : integer );
  var i,j : integer;
begin
  for i := s to t do
    for j := s+1 to t do
      if a[i] < a[j] then
        swap(a[i], b[j]);
end

procedure Copiar( o,s,t : integer );
  var d : integer;
begin
  for d := 0 to t-s do
    b[o+d] := a[s+d];
end

procedure Secuencial();
   var i : integer;
begin
   Sort(1, 2*n); {ordena a}
   Copiar(1, 2*n); {copia a en b}
end
\end{lstlisting}
\caption{Ejemplo de ordenación y copia de arrays con procedimientos en pseudocódigo.}
\label{fig:ejemplo2}
\end{figure}

A partir de este ejemplo también podemos encontrar una serie de características importantes para la definición del lenguaje \textit{Lamport}:

\begin{itemize}
    \item \textbf{Definición de Arrays}: Los arrays \code{a} y \code{b} se definen con tamaños basados en una constante predefinida \code{n}. Estos arrays almacenan valores enteros y sirven como ejemplos principales para las operaciones de ordenación y copia.

    \item \textbf{Definición de Procedimientos}: Los procedimientos como \code{Sort} (línea 3), \code{Copiar} (línea 12) y \code{Secuencial}, (línea 19) demuestran cómo se pueden encapsular tareas específicas y reutilizarlas a lo largo del código.

    \item \textbf{Bucles For}: Los bucles son una herramienta esencial para iterar sobre colecciones de datos y realizar operaciones repetitivas. El uso de bucles \code{for} en este ejemplo muestra cómo se pueden manejar conjuntos de datos de manera eficiente.

    \item \textbf{Estructuras Condicionales (If)}: Las estructuras condicionales, como el \code{if} (línea 8), son prácticamente imprescindibles en la programación. Permiten que un programa evalúe condiciones y tome decisiones basadas en esas evaluaciones. Esta capacidad es fundamental para controlar el flujo de ejecución y adaptar el comportamiento del programa según diferentes situaciones o entradas.
\end{itemize}

\subsubsection{Ejemplo 3: Concurrencia entre instrucciones de un proceso}\label{subsubsec:pseudoAnalisisEjemplo3}
En este ejemplo, exploramos una prueba sencilla de una forma de representación de la concurrencia en el pseudocódigo. Se introduce el concepto de \code{cobegin} y \code{coend}, que marcan el inicio y el fin de un bloque de código que se ejecuta concurrentemente. El código dentro de este bloque puede considerarse como una serie de operaciones que tienen la capacidad de ejecutarse simultáneamente, lo que implica que no hay un orden garantizado de ejecución entre las sentencias que se encuentran en dicho bloque.

\begin{figure}[h]
\begin{lstlisting}[style=lamportStyle]
process P;
var x : integer := 0;
cobegin
  x := x+1 ; x := x+2;
coend
\end{lstlisting}
\caption{Ejemplo simple de programa concurrente.}
\label{fig:ejemplo3}
\end{figure}

También tendremos en cuenta este ejemplo para identificar algunos aspectos del lenguaje \textit{Lamport}, detallándolos a continuación:

\begin{itemize}
    \item \textbf{Instrucciones Concurrentes}: El bloque que comienza con \code{cobegin} y termina con \code{coend} (desde línea 3 hasta línea 5) se utiliza para indicar la ejecución concurrente de instrucciones. Dentro de este bloque, las instrucciones se ejecutan de manera concurrente, lo que significa que no hay un orden garantizado entre ellas.
\end{itemize}

\subsubsection{Ejemplo 4: Instrucciones compuestas atómicas}\label{subsubsec:pseudoAnalisisEjemplo4}

En este ejemplo, se ilustra la ejecución de instrucciones compuestas atómicas. En el contexto del pseudocódigo y especialmente en programación concurrente, la atomicidad asegura que las operaciones se ejecutan completamente o no se ejecutan en absoluto, sin posibilidad de interrupción. Es una característica crucial para evitar condiciones de carrera y garantizar la coherencia de los datos.

\begin{figure}[h]
\begin{lstlisting}[style=lamportStyle]
begin
  x := 0;
  cobegin
    < x := x+1 >
    < x := x-1 >
  coend
end
\end{lstlisting}
\caption{Ejemplo de programa con instrucciones atómicas.}
\label{fig:ejemplo4}
\end{figure}

\newpage 

Se tendrán en cuenta las siguientes características a partir de este ejemplo:

\begin{itemize}
    \item \textbf{Instrucciones Atómicas}: Las instrucciones rodeadas por \textless \textgreater \hspace{0.1cm} representan operaciones atómicas. Estas instrucciones no pueden ser interrumpidas y se ejecutan completamente sin interferencia externa. En este caso, \code{x := x+1} (linea 4) y \code{x := x-1} (linea 5) se ejecutarán de manera atómica.
\end{itemize}

\subsubsection{Ejemplo 5: Creación de procesos no estructurada. Fork-Join.}\label{subsubsec:pseudoAnalisisEjemplo5}
En este cuarto ejemplo, exploramos una característica interesante del pseudocódigo: la creación dinámica de procesos y su sincronización. En muchos sistemas, especialmente en entornos paralelos o distribuidos, la habilidad de crear procesos en tiempo de ejecución y sincronizarlos correctamente es esencial. Veamos cómo \textit{Lamport} aborda esto a través de los comandos \code{fork} y \code{join}.

\begin{figure}[h]
\begin{lstlisting}[style=lamportStyle]
procedure P1;
begin
  A;
  fork P2;
  B;
  join P2;
  C;
end

procedure P2;
begin
  D;
end;
\end{lstlisting}
\caption{Ejemplo de creación dinámica de procesos y sincronización en pseudocódigo.}
\label{fig:ejemplo5}
\end{figure}

Las características más importantes a considerar en este ejemplo son las siguientes:

\begin{itemize}
    \item \textbf{Creación Dinámica de Procesos}: En la línea 3, se utiliza la sentencia \code{fork}, que indica la creación de un nuevo proceso en tiempo de ejecución. En este caso, se lanza el proceso \code{P2}.
    
    \item \textbf{Sincronización de Procesos}: Tras la ejecución de ciertas instrucciones, hay que comprobar que los procesos se sincronicen para garantizar la coherencia. En la línea 5, la sentencia \code{join} asegura que el proceso \code{P1} espere a que \code{P2} termine antes de continuar.
    
    \item \textbf{Orden de Ejecución}: Aunque esto no es una característica explícita de la sintaxis del lenguaje, es importante para comprender el funcionamiento de las sentencias anteriores. Observando el flujo de ejecución, primero se ejecuta la instrucción \code{A} en \code{P1}, luego se inicia \code{P2}, y después de eso, \code{P1} ejecuta la instrucción \code{B}. Sin embargo, antes de que \code{P1} pueda continuar con \code{C}, debe esperar a que \code{P2} haya completado su ejecución.
\end{itemize}

\subsubsection{Ejemplo 6: Definición estática de vectores de procesos.}\label{subsubsec:pseudoAnalisisEjemplo6}
En este ejemplo se muestra una característica importante en la definición y manejo de procesos: la definición estática de vectores de procesos. Esto permite tener un conjunto de procesos con características similares, pero con un identificador específico (usualmente un índice) que permite individualizar su comportamiento. Esta estructura es especialmente útil en entornos donde se requiere un comportamiento similar, pero ligeramente diferente, para un conjunto de tareas o procesos.

\begin{figure}[h]
\begin{lstlisting}[style=lamportStyle]
var ... {variables compartidas}

process NomP[ind : a..b];
var ... {variables locales}
begin
  ... {codigo}
  ... {ind vale a, a+b, ..., b}
end
\end{lstlisting}
\caption{Ejemplo de definición estática de procesos en pseudocódigo.}
\label{fig:ejemplo6}
\end{figure}

Aquí, las características más importantes a considerar son las siguientes:

\begin{itemize}
    \item \textbf{Vectores de Procesos}: La estructura \code{process NomP[ind : a..b]} permite definir un conjunto o vector de procesos, que van desde el índice \code{a} hasta el índice \code{b}. Cada proceso individual puede ser referenciado por su índice específico, que es \code{ind}.

\end{itemize}

\newpage

Tras revisar diversos ejemplos del pseudocódigo \textit{Lamport}, es evidente la flexibilidad y adaptabilidad que este tipo de representación ofrece. No obstante, el pseudocódigo, por su naturaleza intrínseca, carece de una consistencia estricta. Aunque es valioso para transmitir ideas y lógica de programación de forma intuitiva, su falta de rigidez puede llevar a ambigüedades o interpretaciones múltiples. Es aquí donde radica la importancia de definir un lenguaje convencional con una estructura y gramática claramente establecidas. En la siguiente sección, abordaremos el desafío de formalizar el lenguaje \textit{Lamport} a través de una gramática bien definida, sentando así las bases para un entendimiento unificado y coherente de su estructura y funcionamiento.

\section{La gramática del lenguaje Lamport}\label{sec:gramaticaLamport}
En esta sección, se desglosará la estructura fundamental del lenguaje \textit{Lamport}. Se comenzará por definir los tokens, que son los símbolos terminales que forman las unidades básicas del lenguaje. Posteriormente, para la descripción detallada de la gramática, se recurrirá a la notación BNF (Backus-Naur Form), una herramienta valorada por su claridad y precisión en la definición de gramáticas de lenguajes de programación. Más allá de la estructura sintáctica, también se abordará una descripción semántica del lenguaje, garantizando un entendimiento profundo de cómo se traducen las instrucciones en comportamientos específicos. Así, se proporcionará una visión completa de las capacidades y limitaciones de \textit{Lamport}, estableciendo una base sólida para el desarrollo de aplicaciones y sistemas concurrentes.

\subsection{Componentes del lenguaje}\label{subsec:componentesLamport}

Antes de describir formalmente la gramática de Lamport, es menester indicar que el lenguaje está compuesto por una serie de componentes clave que definen su estructura y funcionalidad. A continuación, se describen estos componentes, dejando este convenio de nombres para cuando se necesite en sucesivos capítulos o secciones posteriores:

\begin{itemize}
    \item \textbf{Declaraciones:} Son instrucciones que definen variables, constantes u otros elementos identificables, reservando memoria o estableciendo valores iniciales. Por ejemplo, la declaración de una variable puede ser \code{int x;} donde se está reservando espacio para un entero llamado x.

    \item \textbf{Expresiones:} Son combinaciones de constantes, variables, operadores y funciones que son evaluadas para producir un valor. Ejemplo: \code{x + y - 3}.

    \item \textbf{Sentencias:} Son instrucciones que realizan una acción específica. Puede ser una asignación, una llamada a una función, un bucle for o while, entre otros. Por ejemplo: \code{x = x + 1;}.

    \item \textbf{Procesos:} Se refieren a conjuntos de sentencias que juntas llevan a cabo una tarea específica dentro del programa. 

    \item \textbf{Subprogramas:} Este término puede referirse tanto a funciones como a procedimientos. Son segmentos de código que tienen un propósito definido y pueden ser llamados con ciertos parámetros. Permiten modularizar el código y reutilizar funcionalidades. Las funciones siempre devuelven un valor, mientras que los procedimientos no. 

    Ejemplo:
    \begin{verbatim}
    procedure mostrarMensaje();
    begin
        print("¡Hola Mundo!");
    end

    function sumaNumeros(a : integer, b : integer) : integer;
    begin
        return a+b;
    end
    \end{verbatim}

    \item \textbf{Parámetro de Subprograma:} Un parámetro es una variable que se utiliza para pasar información entre subprogramas. Los parámetros permiten que los subprogramas sean más flexibles y reutilizables, ya que pueden operar con diferentes datos cada vez que se llaman. Los parámetros se especifican en la definición del subprograma y se pasan valores cuando se llama al subprograma. Por ejemplo, en la función \code{sumaNumeros} anterior, \code{a} y \code{b} son parámetros.


\end{itemize}

\subsection{Tokens del lenguaje Lamport}\label{subsec:tokensLamport}
En esta subsección, se abordará una de las partes importantes en la definición de un lenguaje de programación: los tokens. Los tokens, también conocidos como símbolos terminales, representan las unidades léxicas mínimas que componen las sentencias y expresiones del lenguaje. Su identificación y clasificación permiten una interpretación estructurada del código fuente y facilitan la comprensión de la sintaxis del lenguaje. A continuación, se presentarán y describirán los tokens específicos que conforman el lenguaje \textit{Lamport}, proporcionando una base sólida para entender su estructura y funcionamiento. En la siguiente tabla se recogen todos los tokens del lenguaje, especificando el nombre de token, una breve descripción, un patrón de reconocimiento y un ejemplo si procede:

\newpage

\renewcommand{\arraystretch}{1.5}
\begin{longtable}{|c|M{4cm}|M{4cm}|M{2.5cm}|}
\caption{Tokens del lenguaje Lamport.} \label{tab:tokensLamport} \\
\hline
\textbf{TOKEN} & \textbf{DESCRIPCIÓN INFORMAL} & \textbf{PATRÓN} & \textbf{EJEMPLO} \\
\hline
\endfirsthead

\multicolumn{4}{c}%
{{\bfseries \tablename\ \thetable{} -- continuación de la página anterior}} \\
\hline
\textbf{TOKEN} & \textbf{DESCRIPCIÓN INFORMAL} & \textbf{PATRÓN} & \textbf{EJEMPLO} \\
\hline
\endhead

\hline \multicolumn{4}{|r|}{{Continúa en la siguiente página}} \\
\hline
\endfoot

\hline
\endlastfoot

\code{S_PROGRAM} & Palabra reservada para indicar el inicio del programa. & ``\code{program}'' & program \\
\hline
\code{S_VAR} & Palabra reservada para declarar variables. & ``\code{var}'' & var \\
\hline
\code{T_INTEGER} & Palabra reservada para el tipo entero. & ``\code{integer}'' & integer \\
\hline
\code{T_BOOLEAN} & Palabra reservada para el tipo boolean. & ``\code{boolean}'' & boolean \\
\hline
\code{T_CHAR} & Palabra reservada para el tipo carácter. & ``\code{char}'' & char \\
\hline
\code{T_STRING} & Palabra reservada para el tipo cadena de caracteres. & \code{string}'' & string \\
\hline
\code{T_REAL} & Palabra reservada para el tipo real (flotante). & ``\code{real}'' & real \\
\hline
\code{T_ARRAY} & Palabra reservada para declarar un vector. & ``\code{array}'' & array \\
\hline
\code{T_SEMAPHORE} & Palabra reservada para el tipo semáforo. & ``\code{semaphore}'' & semaphore \\
\hline
\code{T_DPROCESS} & Palabra reservada para declarar un proceso dinámico & ``\code{dprocess}'' & dprocess \\
\hline
\code{S_PROCESS} & Palabra reservada para indicar el inicio de un proceso & ``\code{process}'' & process \\
\hline
\code{S_PROCEDURE} & Palabra reservada para indicar el inicio de un procedimiento. & ``\code{procedure}'' & procedure \\
\hline
\code{S_FUNCTION} & Palabra reservada para indicar el inicio de una función & ``\code{function}'' & function \\
\hline
\code{RETURN} & Palabra reservada para indicar el retorno de una función & ``\code{return}'' & return \\
\hline
\code{B_BEGIN} & Palabra reservada para indicar el inicio de un bloque. & ``\code{begin}'' & begin \\
\hline
\code{B_END} & Palabra reservada para indicar el fin de un bloque. & ``\code{end}'' & end \\
\hline
\code{B_COBEGIN} & Palabra reservada para indicar el inicio de un bloque paralelo. & ``\code{cobegin}'' & cobegin \\
\hline
\code{B_COEND} & Palabra reservada para indicar el fin de un bloque paralelo. & ``\code{coend}'' & coend \\
\hline
\code{S_FORK} & Palabra reservada para indicar inicio del fork. & ``\code{fork}'' & fork \\
\hline
\code{JOIN} & Palabra reservada para sincronización de dprocess & ``\code{join}'' & join \\
\hline
\code{SLEEP} & Palabra reservada para dormir proceso & ``\code{sleep}'' & sleep \\
\hline
\code{IF} & Palabra reservada para estructura de control if. & ``\code{if}'' & if \\
\hline
\code{THEN} & Palabra reservada para condición then de if. & ``\code{then}'' & then \\
\hline
\code{ELSE} & Palabra reservada para condición else de if. & ``\code{else}'' & else \\
\hline
\code{WHILE} & Palabra reservada para estructura de control while. & ``\code{while}'' & while \\
\hline
\code{DO} & Palabra reservada para el bucle do de while. & ``\code{do}'' & do \\
\hline
\code{FOR} & Palabra reservada para estructura de control for. & ``\code{for}'' & for \\
\hline
\code{TO} & Palabra reservada para indicar límite bucle for. & ``\code{to}'' & to \\
\hline
\code{IDENT} & Identificador de variables, funciones, procedimientos. & ``\code{[a-zA-Z] ([a-zA-Z] \| [0-9])*}'' & x, aux, sum, proc1B \\
\hline
\code{LITERAL} & Secuencia de caracteres entre comillas dobles. & \code{\"^.*?\"\$} & "Hola Mundo!" \\
\hline
\code{L_INTEGER} & Literal entero. & ``\code{^-?[0-9]+\$}'' & 2, -31, 0 \\
\hline
\code{L_REAL} & Literal flotante. & ``\code{^-?[0-9]+ (\.[0-9]+)?\$}'' & 2.71, -6, -4.1314 \\
\hline
\code{L_BOOLEAN_TRUE} & Literal booleano (verdadero) & ``\code{true}'' & true \\
\hline
\code{L_BOOLEAN_FALSE} & Literal booleano (falso) & ``\code{false}'' & false \\
\hline
\code{L_CHAR} & Carácter entre comillas simples. & ``\code{^'.'\$}'' & 'A', '4', '?' \\
\hline
\code{OP_ASSIGN} & Operador de asignación. & ``\code{:=}`` & := \\
\hline
\code{OP_REL_LT} & Operador de comparación (menor que). & ``$<$'' & $<$ \\
\hline
\code{OP_REL_GT} & Operador de comparación (mayor que). & ``$>$'' & $>$ \\
\hline
\code{OP_REL_LTE} & Operador de comparación (menor o igual que). & ``$<=$`` & $<=$ \\
\hline
\code{OP_REL_GTE} & Operador de comparación (mayor o igual que). & ``$>=$`` & $>=$ \\
\hline
\code{OP_REL_EQ} & Operador de comparación (igual que). & ``\code{==}`` & == \\
\hline
\code{OP_REL_NEQ} & Operador de comparación (distinto que) & ``\code{\!=}`` & != \\
\hline
\code{OP_NOT} & Operador negación lógica. & ``\code{not}'' & not \\
\hline
\code{OP_AND} & Operador conjunción lógica. & ``\code{and}'' & and \\
\hline
\code{OP_OR} & Operación disyunción lógica. & ``\code{or}'' & or \\
\hline
\code{OP_SUM} & Operador suma & ``\code{+}'' & + \\
\hline
\code{OP_MINUS} & Operador resta & ``\code{-}'' & - \\
\hline
\code{OP_MULT} & Operador multiplicación & ``\code{*}'' & * \\
\hline
\code{OP_DIV} & Operador división & ``\code{/}'' & / \\
\hline
\code{OP_MOD} & Operador módulo & ``\code{\%}'' & \% \\
\hline
\code{PAR_IZDO} & Paréntesis izquierdo & ``\code{(}'' & ( \\
\hline
\code{PAR_DCHO} & Paréntesis derecho & ``\code{)}'' & ) \\
\hline
\code{CORCH_IZDO} & Corchete izquierdo & ``\code{[}'' & [ \\
\hline
\code{CORCH_DCHO} & Corchete derecho & ``\code{]}'' & ] \\
\hline
\code{DELIM_C} & Delimitador (coma) & ``\code{,}'' & , \\
\hline
\code{DELIM_PC} & Delimitador (punto y coma) & ``\code{;}'' & ; \\
\hline
\code{DELIM_2P} & Delimitador (dos puntos) & ``\code{:}'' & : \\
\hline
\code{DELIM_P} & Delimitador (punto) & ``\code{.}'' & . \\
\hline
\code{DELIM_ARR} & Delimitador de size de array & ``\code{..}'' & .. \\
\hline
\code{ATOM_INI} & Delimitador inicio sección atómica & ``$<$$<$'' & $<$$<$ \\
\hline
\code{ATOM_FIN} & Delimitador fin sección atómica & ``$>$$>$'' & $>$$>$ \\
\hline
\code{SEM_WAIT} & Indica operación wait sobre semáforo & ``\code{WAIT}'' & WAIT \\
\hline
\code{SEM_SIGNAL} & Indica operación signal sobre semáforo & ``\code{SIGNAL}'' & SIGNAL \\
\hline

\end{longtable}
\renewcommand{\arraystretch}{1.0}

Para la designación de las clases de los tokens, se ha decidido utilizar un convenio en el prefijo donde:

\begin{itemize}
    \item \textit{S\_} delimita aquellos símbolos que indican el inicio de un evento (programa, procedimiento, 
    función...).
    \item \textit{T\_} delimita aquellos símbolos relacionados con el tipo de dato (integer, real, array,...).
    \item \textit{B\_} delimita aquellos símbolos relacionados con un bloque (inicio, fin).
    \item \textit{L\_} delimita aquellos símbolos relacionados con literales (literal entero, flotante, booleano, char,...).
    \item \textit{OP\_} delimita aquellos símbolos que son operadores (binarios, de comparación,...).
\end{itemize}

\subsection{Descripción de la Gramática del lenguaje Lamport utilizando la notación Backus-Naur Form (BNF)}\label{subsec:sintaxisLamport}

La notación Backus-Naur Form (BNF), inventada por John Backus y Peter Naur, proporciona una forma concisa y comprensible de definir la gramática de un lenguaje, permitiendo a los desarrolladores y analistas de lenguajes comprender rápidamente su estructura. Al describir la gramática de Lamport mediante BNF, se ofrece una visión clara y detallada de cómo se estructura este lenguaje y cómo pueden formarse instrucciones válidas dentro de él.



A continuación, se presentan una serie de reglas y tokens definidos con la notación BNF para el lenguaje Lamport, con base en los ejemplos mencionados en la sección anterior. Estas reglas servirán como una guía para aquellos interesados en profundizar en la programación o análisis de este lenguaje, facilitando su aprendizaje y evitando ambigüedades en su interpretación.

\newpage

\begin{BNFCode}
# Definicion de reglas de sintaxis de creacion de programas
<program> ::= "program" <identifier> [";"] [<declarations>] 
    (<subprogram>)* <process>+

# Definion de reglas de sintaxis de creacion de declaraciones de variable
# Las declaraciones de variables se pueden encontrar:
#  --- Al principio de un programa: variables globales
#  --- Al principio de un subprograma: variables locales
#  --- Al principio de un proceso: variables locales
<declarations> ::= ("var" <identifier> ":" <type> 
    [":=" <expression>] ";")+

# Definicion de reglas de sintaxis de creacion de tipos
# Los tipos pueden ser:
#  --- Atomicos (basicos) : INTEGER, REAL, CHAR, STRING, BOOLEAN
#  --- Compuestos : ARRAY [size].
#  --- Especiales : SEMAPHORE, DPROCESS
<type> ::= <basic-type-or-array>
    | <special-type>

<basic-type-or-array> ::= <basic-type>
    | "array" "[" <expression> "]" <basic-type>

<special-type> ::= "semaphore"
    | "dprocess"

<basic-type> ::= "integer"
    | "real"
    | "char"
    | "string"
    | "boolean"
 
# Definicion de reglas de sintaxis de creacion de subprogramas
# Los subprogramas pueden ser:
#  --- Funciones : retornan tipo de dato (basicos)
#  --- Procedimientos : no retornan datos (funciones void)
<subprogram> ::= <procedure-definition>
	| <function-definition>


<procedure-definition> ::= "procedure" <identifier> 
    "(" <parameters> ")" ";" [<declarations>] 
    <block-statements-begin-end>
	
<procedure-function> ::= "function" <identifier> 
    "(" <parameters> ")" ":" <basic-type>
    ";" [<declarations>] <block-statements-function>
    
# Definicion de reglas de sintaxis de creacion de parametros
# Los parametros son listas de identificadores seguidos de un tipo de dato
<parameters> ::= [<parameter> ["," <parameters>]]
<parameter> ::= <identifier> ":" <basic-type>

# Definicion de reglas de sintaxis de creacion de procesos
# Los procesos pueden ser:
#   --- Normales (Single).
#   --- Vectorizados. Definen una serie de procesos con base en un indexador
<process> ::= "process" <identifier> [ "[" <identifier> : 
    <expression> ".." <expression> "]" ] ";" 
    [<declarations>] <block-statements-begin-end>


# Definicion de reglas de sintaxis de sentencias
# Las diferentes sentencias disponibles para el lenguaje son:
#   --- Bloque de sentencias BEGIN/END
#   --- Bloque de sentencias COBEGIN/COEND
#   --- Bloque de sentencias ATOMICAS
#   --- Asignacion
#   --- Bucle for
#   --- Bucle while
#   --- If/else
#   --- Fork
#   --- Join
#   --- Sleep
#   --- Llamada a procedimiento
#   --- Impresion de contenido (print)
#   --- Operacion wait sobre semaforo
#   --- Operacion signal sobre semaforo
<block-statements-begin-end> ::= "begin" (<statement>)+ "end"
<block-statements-cobegin-coend> ::= "cobegin" 
    (<statement>)+ "coend"
<block-statements-atomic> ::= "<<" (statement)+ ">>"
<block-statements-function> ::= "begin" (<statement>)+ 
    <return-statement> "end"
	
<statement> ::= <assignment-statement>
    | <while-statement>
    | <for-statement>
    | <if-statement>
    | <procedure-call-statement>
    | <block-statements-atomic>
    | <block-statements-cobegin-coend>
    | <fork-statement>
    | <join-statement>
    | <sleep-statement>
    | <print-statement>
    | <sem-wait-statement>
    | <sem-signal-statement>
	
<assignment-statement> ::= <identifier> ["[" <expression> "]"] 
    ":=" <expression> ";"
    
<while-statement> ::= "while" <expression> "do" 
    <block-statements-begin-end>
    
<for-statement> ::= "for" <identifier> ":=" <expression> "to" 
    <expression> "do" <block-statements-begin-end>
    
<if-statement> ::= "if" <expression> "then" 
    <block-statements-begin-end> 
    ["else" <block-statements-begin-end>]
    
<procedure-call-statement> ::= <identifier> "(" <arguments> ")" ";"

<fork-statement> ::= "fork" <identifier> ";"

<join-statement> ::= "join" ";"

<sleep-statement> ::= "sleep" <expression> ";"

<print-statement> ::= "print" "(" <print-list> ")" ";"
<print-list> ::= <expression> ("," <expression>)*

<return-statement> ::= "return" <expression> ";"

<sem-wait-statement> ::= "WAIT" <identifier> ";"
<sem-signal-statement> ::= "SIGNAL" <identifier> ";"

# Definicion de reglas de sintaxis de expresiones
# Las diferentes expresiones disponibles para el lenguaje son:
#   --- binarias (<expression> simbolo <expresion>)
#   --- unarias  (simbolo <expression>)
#   --- literales (INTEGER, REAL, CHAR, STRING, BOOLEAN)
#   --- identificador (variable de tipo basico/ARRAY)
#   --- llamada a funcion
#   --- expresion entre parentesis
<expression> ::= <expression> <binary-operator> <expression>
	| <unary-operator> <expression>
	| <term>

<term> ::= <identifier> ["[" <expression> "]"]
	| <literal-expression>
	| <function-call-expression>
	| "(" <expression> ")"
	
<literal-expression> ::= <integer-literal>
	| <real-literal>
	| <string-literal>
	| <char-literal>
	| <boolean-literal>
	
<integer-literal> ::= <digit>+
<boolean-literal> ::= "true" | "false"
<string-literal> ::= ``cualquier secuencia de caracteres del juego de caracteres en uso, con comillas dobles al inicio y al final''
<char-literal> ::= ``cualquier caracter del juego de caracteres en uso, con comilla simple al inicio y al final''
<real-literal> ::= <integer-literal> "." <integer-literal>
<identifier> ::= <letter> (<leter-or-digit>)*
<letter-or-digit> ::= <letter> | <digit>
<letter> ::= [a-zA-Z]
<digit> ::= [0-9]

<function-call-expression> ::= <identifier> "(" <arguments> ")"

<binary-operator> ::= "*" | "/" | "+" | "-" | "%" |
 	| ">" | "<" | "<=" | ">=" | "==" | "!="
	| "and" | "or"
<unary-operator> ::= "-" | "not"

# Definicion de reglas de sintaxis de generacion de argumentos
<arguments> ::= [<expression> ["," <arguments>]]
\end{BNFCode}

\noindent
Sobre las características del metalenguaje de BNF hay que destacar que:
\begin{itemize}
    \item El metasímbolo [ ... ] denota una opción: el contenido dentro de los corchetes puede estar presente o no. Por ejemplo, \code{[<declarations>]} indica que se puede una lista de declaraciones.
    \item El metasímbolo ( ... )* indica cero o más repeticiones del contenido dentro de los paréntesis. Por ejemplo, \code{(a|b)*} puede representar cadenas como '', 'a', 'b', 'ab', 'ba', 'aa', 'bb', y así sucesivamente.
    \item El metasímbolo ( ... )+ indica una o más repeticiones del contenido dentro de los paréntesis. Difiere del anterior en que debe haber al menos una ocurrencia. Así, \code{(a|b)+} podría representar 'a', 'b', 'ab', 'ba', 'aa', 'bb', pero no la cadena vacía.
\end{itemize}

\noindent
Y sobre la descrición del lenguaje Lamport, es importante notar que:
\begin{itemize}
    \item Los tokens, representados entre comillas (p.ej. \code{''program''}), denotan palabras clave y símbolos específicos del lenguaje \footnote{Aunque justo en la sección anterior se ha introducido ya la tabla de tokens, para el lector es más agradable visualizar las reglas de esta forma, dejando el patrón de reconocimiento de los tokens en vez de su identificación.}.
    \item Los símbolos <...> \hspace{0.05cm} representan categorías gramaticales, que pueden estar compuestas por otras categorías gramaticales o tokens.
    \item Las reglas son recursivas, permitiendo la construcción de sentencias y expresiones de diversa complejidad y longitud.
    \item Los comentarios, precedidos por el símbolo \#, proporcionan aclaraciones y contextos adicionales sobre las reglas.
\end{itemize}

\subsubsection{Ambigüedades en la gramática}\label{subsubsec:gramaticaAmbiguaLamport}
Al definir la gramática del lenguaje Lamport utilizando la notación BNF, hay que identificar y resolver cualquier ambigüedad que pueda surgir. Una gramática ambigua es aquella en la que una cadena puede tener más de un árbol de derivación, lo que lleva a diferentes interpretaciones de la cadena. En el contexto de los lenguajes de programación, esto puede ser problemático ya que diferentes interpretaciones pueden llevar a diferentes comportamientos del programa. Es por ello por lo que la pregunta que cabe hacerse ahora es: \textit{¿Presenta esta gramática ambigüedades?}



La respuesta es \textbf{sí}, y a continuación, se discuten algunas áreas en la gramática presentada donde podrían surgir ambigüedades y se proporcionan soluciones o aclaraciones para las mismas.

\noindent
\textbf{Expresiones Binarias y Precedencia de Operadores:}

\vspace{0.3cm}

\noindent
La regla:
\begin{BNFCode}
<expression> ::= <expression> <binary-operator> <expression>
| <unary-operator> <expression>
| <term>
\end{BNFCode}



Puede dar lugar a ambigüedades en expresiones como ``\code{a + b * c}''. Sin una clarificación sobre la precedencia de los operadores, no está claro si se debe interpretar como ``\code{(a + b) * c}'' o como ``\code{a + (b * c)}''.



\textbf{Solución:} Establecer reglas separadas para cada nivel de precedencia o modificar la gramática para que refleje explícitamente la precedencia.


\subsection{Descripción Semántica del lenguaje Lamport}\label{subsec:semanticaLamport}

La semántica, en el contexto de los lenguajes de programación, se refiere al significado de los programas. No solo se considera la estructura de un programa (su sintaxis), sino también lo que realiza al ejecutarse (su semántica). En esta sección, se profundizará en la semántica del lenguaje Lamport, desvelando el comportamiento y operación de sus distintos constructos y componentes.

\subsubsection{Descripción semántica general del lenguaje Lamport}
El lenguaje Lamport se puede describir como \textit{inseguro}, \textit{estático} y \textit{explícito}. Esto quiere decir que:

\begin{itemize}
    \item \textbf{Inseguro}: En un lenguaje de programación no seguro, se permiten escribir programas válidos que pueden tener un comportamiento indefinido que viola la estructura básica del programa. Esto por ejemplo se puede ver en los accesos a un ARRAY, donde si tiene tamaño 100 y se accede a una posición fuera de ese rango, compilará, pero puede que su comportamiento será indecible. En este lenguaje en particular si esto sucede se lanzará una excepción.
    \item \textbf{Estático}: La comprobación de tipos se realiza en tiempo de compilación. Cuando llegue el momento de traducir el código a binario (o en el caso de este lenguaje, la interpretación de las instrucciones generadas), no será necesario mantener información del tipo de dato de cada variable, subprograma o parámetro, porque todas las operaciones se habrán verificado y determinado como seguras.
    \item \textbf{Explícito}: El programador es responsable de indicar los tipos de variables o de otros elementos de código explícitamente.
\end{itemize}

\subsubsection{Tipos de datos del lenguaje Lamport}
Con respecto a los tipos de dato del lenguaje Lamport, se tienen los siguientes:
\begin{itemize}
    \item \textbf{Tipos básicos (atómicos)}:
    \begin{itemize}
        \item \code{integer}: entero con signo de 32 bits.
        \item \code{real}: número flotante con signo de 32 bits.
        \item \code{char}: caracteres ASCII.
        \item \code{string}: cadena de caracteres ASCII, terminados en ``\textbackslash 0''.
        \item \code{boolean}: símbolos \code{true} y \code{false}.
    \end{itemize}
    \item \textbf{Tipos compuestos}:
    \begin{itemize}
        \item \code{array [size] <basic-type>}: Array de tamaño \textit{size} y de tipo atómico \textit{<basic-type>}.
    \end{itemize}
\end{itemize}


\subsubsection{Restricciones semánticas}\label{subsubsec:restriccionesSemanticas}
Finalmente, con respecto a las reglas de validación de operaciones:
\begin{itemize}
    \item Sólo se puede asignar un único valor a una variable al mismo tiempo. Definir dos asignaciones diferentes, efectivamente, son dos operaciones distintas.
    \item Un parámetro de función sólo acepta un un valor al mismo tiempo.
    \item En un subprograma función, el tipo de dato que devuelve debe coincidir con el tipo de dato de su sentencia de retorno $<$ \code{return-statement} $>$. Además, esta sentencia \code{return} debe ser \textit{la última que aparezca en el cuerpo de una función}.
    \item Los operadores de comparación de igualdad \code{\!=} y \code{==} pueden aceptar cualquier tipo de dato \textit{básico}.
    \item Los operadores de comparación $<$, $>$, $<=$, $>=$ sólo aceptan o números enteros \code{integer} o reales \code{real} en ambos miembros de la comparación, y además, deben coincidir en tipo.
    \item Los operadores aritméticos \code{+}, \code{-}, \code{*}, \code{/}, sólo aceptan números enteros \code{integer} o reales \code{real} en ambos operandos, y además, deben coincidir en tipo. Es decir, no se pueden aplicar a \code{integer} y \code{real} simultáneamente.
    \item El operador aritmético \code{\%} sólo acepta números enteros \code{integer}.
\end{itemize}



Es necesario indicar al final de esta lista de restricciones semánticas que hay un par de restricciones adicionales que no son motivo intrínseco del lenguaje en sí, sino por cuestiones de implementación, y son:

\begin{itemize}
    \item En una declaración de tipo \code{array} su tamaño debe ser indicado exactamente con un literal entero puro. No se permiten otro tipo de expresiones.
    \item Igual que en el caso anterior, en la definición estática de procesos vectorizados, los límites de principio y fin que delimitan al índice sólo pueden ser indicados exactamente con un literal entero puro.
\end{itemize}

La cuestión de hacer esto es que así se está realizando una declaración de vector (o procesos) estáticos. En otro caso, se debería determinar en tiempo de ejecución el tamaño que hay que dedicar en la memoria de la Máquina Virtual, y reservarla. Esto se verá más detalladamente en el siguiente capítulo de implementación.

\subsubsection{Precedencia y Asociatividad de operadores}\label{subsec:precOperadoresLamport}

La correcta definición de la precedencia y la asociatividad de los operadores es esencial en cualquier lenguaje de programación. Estos dos conceptos dictan el orden en el que se evalúan las operaciones y cómo se agrupan los operandos en presencia de varios operadores. La especificación clara de estas reglas garantiza que los programas se ejecuten de manera coherente y predecible, evitando ambigüedades que podrían llevar a comportamientos inesperados o a errores difíciles de diagnosticar. A continuación, se presenta una tabla que detalla el orden de prioridades y la asociatividad de los operadores en el lenguaje.

\newpage

\renewcommand{\arraystretch}{1.5}
\begin{longtable}{|c|M{3.5cm}|M{3cm}|c|}
\caption{Precedencia y asociatividad de operadores de Lamport.} \label{tab:precedencyOperatorsLamport} \\
\hline
\textbf{PRECEDENCIA} & \textbf{OPERADOR(ES)} & \textbf{DESCRIPCIÓN} & \textbf{ASOCIATIVIDAD} \\
\hline
\endfirsthead

\multicolumn{4}{c}%
{{\bfseries \tablename\ \thetable{} -- continuación de la página anterior}} \\
\hline
\textbf{PRECEDENCIA} & \textbf{OPERADOR(ES)} & \textbf{DESCRIPCIÓN} & \textbf{ASOCIATIVIDAD} \\
\hline
\endhead

\hline \multicolumn{4}{|r|}{{Continúa en la siguiente página}} \\
\hline
\endfoot

\hline
\endlastfoot

1 & $-$ & Operador menos (unario) & Derecha a Izquierda \\
\hline
2 & $*$ \hspace{0.1cm} $/$ \hspace{0.1cm} \% & Multiplicación, división y módulo (binario) & Izquierda a Derecha \\
\hline
3 & $+$ \hspace{0.1cm} $-$ & Suma y resta (binario) & Izquierda a Derecha \\
\hline
4 & $-$ $<$ $<=$ $>$ $>=$ $==$ \code{\!=} & Operadores de comparación (binario) & Izquierda a Derecha \\
\hline
5 & not & Negación lógica (unario) & Derecha a Izquierda \\
\hline
6 & and & Conjunción lógica (binario) & Izquierda a Derecha \\
\hline
7 & or & Disyunción lógica (binario) & Izquierda a Derecha \\

\end{longtable}
\renewcommand{\arraystretch}{1.0}

La enumeración en la primera columna sirve para indicar el orden de análisis de los operadores, en el que un número más pequeño implica una mayor prioridad o importancia. Esto significa que, en una expresión que involucra múltiples operadores, los operadores con menor número se evaluarán antes que aquellos con números mayores. Por ejemplo, en una expresión como \code{2 + 3 * 4}, debido a que la multiplicación tiene una mayor prioridad (2) que la suma (3), se evaluará primero \code{3 * 4} y luego se sumará \code{2} al resultado.



La columna de asociatividad informa sobre cómo se evalúan los operadores cuando aparecen varios del mismo tipo en una secuencia sin paréntesis claros para determinar el orden. La asociatividad ``\textit{Izquierda a Derecha}'' indica que, en caso de una secuencia de operadores con la misma precedencia, se comenzará a evaluar desde el operador más a la izquierda y se procederá hacia la derecha. Por ejemplo, en la expresión \code{5 - 3 - 2}, se evaluará primero \code{5-3} debido a esta asociatividad, y luego se restará \code{2} al resultado. Por otro lado, la asociatividad ``\textit{Derecha a Izquierda} implica que la evaluación comienza con el operador más a la derecha y procede hacia la izquierda. Este tipo de asociatividad es menos común y generalmente se encuentra en operadores unarios, como el operador negativo unario mostrado en la tabla.

\section{Conclusiones del estudio}
A lo largo de este capítulo, se ha llevado a cabo un estudio detallado y sistemático del lenguaje Lamport, desde su concepción mediante el análisis del pseudocódigo base propuesto en la asignatura \textit{Sistemas Concurrentes y Distribuidos} hasta su posterior diseño. Se ha descrito la estructura gramatical, que es el núcleo de cualquier lenguaje, proporcionando una visión clara y concisa de cómo se construyen y analizan las sentencias en Lamport.


\noindent
Ahora, podemos definir formalmente la gramática de Lamport como la cuádrupla:

$$
G = (V,T,P,S)
$$

\noindent
donde:

\begin{itemize}
    \item $V$ es el conjunto de símbolos no terminales, definidos en la parte izquierda de las reglas de sintaxis definidas en la subsección ~\ref{subsec:sintaxisLamport}.
    \item $T$ son el conjunto de símbolos terminales que han sido representados mediante tokens, y recogidos en una tabla junto con su patrón de reconocimiento en la subsección ~\ref{subsec:tokensLamport}.
    \item $P$ es un conjunto finito de producciones, detallado en la subsección ~\ref{subsec:sintaxisLamport}.
    \item $S$ es un elemento de $V$ que corresponde al \textit{símbolo de partida}, y es el símbolo \hspace{0.5cm} $<$ \code{program} $>$.
\end{itemize}

Además, se ha discutido acerca de la ambigüedad de la gramática en la subsección ~\ref{subsubsec:gramaticaAmbiguaLamport}, donde se han proporcionado algunas soluciones para la resolución de dichas ambigüedades, como en el caso de evaluación de expresiones utilizando una tabla de precedencia de operadores, definida en la subsección ~\ref{subsec:precOperadoresLamport}.



Para finalizar, se puede concluir que la gramática definida siguiendo la Jerarquía de Chomsky es de \textbf{tipo 2} (~\ref{section:chomsky} ), o en otras palabras, es una \textbf{gramática independiente del contexto}, y genera el lenguaje Lamport, denotado como $\mathscr{L}$.



En el siguiente capítulo, comprobaremos que aplicando algunas modificaciones a las reglas y eliminando las ambigüedades, la gramática es \code{LALR(1)} \cite{aho1990compiladores} (sección 4.7.4), puesto que el generador de analizadores sintácticos Bison, es capaz de procesar la gramática sin notificar ningún de conflicto de tipo reducción o desplazamiento.

