\chapter{\textbf{Conclusiones y trabajos futuros}}

\section{Conclusiones}
Este proyecto ha abarcado dos áreas fundamentales relacionadas con los sistemas concurrentes y distribuidos. Primero, se llevó a cabo un estudio exhaustivo de los sistemas concurrentes, centrando la atención en una especificación formal como la propuesta por Leslie Lamport en su Lógica Temporal de Acciones (TLA). Este análisis detallado no solo proporcionó una base teórica sólida para entender la complejidad inherente a estos sistemas, sino que también destacó la importancia de una especificación rigurosa para su correcto diseño y verificación, a través del formalismo matemático.

En segundo lugar, se adoptó un enfoque práctico mediante el desarrollo de un intérprete para un lenguaje de programación diseñado específicamente para simular sistemas concurrentes y distribuidos. Este lenguaje se basó en el pseudocódigo utilizado en la asignatura ``Sistemas Concurrentes y Distribuidos'', permitiendo así una mayor accesibilidad y comprensión para aquellos familiarizados con el curso. La implementación de este intérprete se realizó siguiendo una metodología de desarrollo ágil, lo que facilitó un proceso de desarrollo iterativo y adaptable.

Durante este proceso, se utilizaron herramientas avanzadas de programación, incluyendo analizadores léxicos y sintácticos, y se aprovecharon las capacidades de los lenguajes C y C++ para asegurar un rendimiento óptimo y una integración efectiva. Esta combinación de teoría y práctica no solo ha enriquecido la comprensión de los sistemas concurrentes y distribuidos, sino que también ha proporcionado una herramienta valiosa para su estudio y simulación.

Al concluir este proyecto, se ha logrado un balance entre la teoría formal y la aplicación práctica, proporcionando una perspectiva integral de los sistemas concurrentes y distribuidos. Este trabajo no solo sirve como un recurso educativo para aquellos que buscan profundizar en este campo, sino que también sienta las bases para futuras investigaciones y desarrollos en esta área tan dinámica y desafiante de la informática.

\section{Trabajos futuros}
Desarrollar un intérprete completo para dar vida a un nuevo lenguaje de programación es cuanto menos desafiante, además teniendo en cuenta los cortos plazos de tiempo en los que se han desarrollado. Puesto que el software siempre está en continua evolución y en continua obsolescencia, hay algunos aspectos que se pueden mejorar y nuevas que desarrollar, citadas a continuación:

\begin{itemize}
    \item \textbf{SAAS (Software As A Service)}: Con el intérprete ya dockerizado, una prometedora dirección futura para este proyecto es su desarrollo y lanzamiento como Software as a Service (SaaS). Esta transición a una plataforma basada en la nube no solo facilitaría un acceso más amplio y flexible al intérprete, sino que también permitiría una gestión más eficiente y la implementación rápida de actualizaciones y mejoras. Al ofrecer el intérprete como un servicio en la nube, podríamos expandir significativamente su alcance y utilidad, proporcionando una herramienta valiosa y accesible para una audiencia global interesada en la simulación y el estudio de sistemas concurrentes y distribuidos.
    \item \textbf{Nuevos mecanismos de sincronización y ampliación de la gramática}: De forma nativa el intérprete permite definir semáforos como mecanismo de sincronización de hebras, por lo que quizá estaría bien considerar otras como ``Monitores''. También, puede considerarse ampliar la gramática de Lamport permitiendo nuevos constructos que faciliten el uso por parte del usuario.
    \item \textbf{Reimplementación de intérprete en C++}: En este proyecto se utilizó C y C++ como lenguajes de desarrollo del intérprete, dejando C para la parte más cercana a la fase de análisis de código (léxico, sintáctico y semántico). Aunque C es un lenguaje muy versátil a día de hoy, su sucesor C++ implementa características más seguras, en lo que concierne a gestión de memoria dinámica vía punteros. Por otra parte, su sintaxis orientada a objetos y sus múltiples bibliotecas estándar hace que la definición y/o uso de estructuras de datos sea más directa que en C, y como Flex y Bison permiten generar analizadores para este lenguaje, quizá sería conveniente reimplementar todos esos módulos con este lenguaje, garantizando más seguridad y claridad.
    \item \textbf{Gestión de errores sintácticos uniforme}: Se podría mejorar la gestión actual de los errores sintácticos por parte de Bison, definiendo unas reglas de producción más granulares y específicas, incluso teniendo en cuenta patrones incorrectos debido a tokens que no debían estar ahí.
    \item \textbf{Habilitar expresiones en definición de arrays}: Gestionar la memoria en tiempo de ejecución es una tarea ardua si las implementaciones deben hacerse desde cero, y es por eso por lo que la gramática actual, aunque contemple cualquier tipo de expresión para la declaración de arrays, se considera semánticamente incorrecta la declaración si dicha expresión no contiene exactamente un literal entero. Es por ello por lo que dentro de la memoria de la máquina virtual se podría considerar un heap que permita obtener el tamaño de los arrays en tiempo de ejecución.
    \item \textbf{Simulación realista de la asignación de los registros}: Con la estrategia actual la simulación que hace la máquina virtual es menos realista que lo que se hace en una máquina convencional. Se podría considerar cambiar esta mecánica de decisión de registros a la hora de generar las instrucciones de la representación intermedia, comprobando la vivacidad de los registros.
\end{itemize}

Para concluir, este proyecto no solo representa un paso significativo en la simulación y estudio de sistemas concurrentes y distribuidos, sino que también establece una sólida base para futuras innovaciones y mejoras. Con estas vías futuras, el proyecto está bien posicionado para adaptarse y evolucionar, manteniéndose relevante y útil en un campo que está en constante cambio y crecimiento.